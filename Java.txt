========================
СИСТЕМА УПРАВЛЕНИЯ ВЕРСИЯМИ
========================

GIT 
http://progit.org/book/ru/

SUBVERSION
http://svnbook.red-bean.com/nightly/ru/svn-book.html



========================
СБОРЩИК МУСОРА
========================

Сборщик мусора в Java работает в адаптивном режиме.
Сначала работает в режиме "пометить и убрать", если
появляется излишняя фрагментация кучи то, переходит
в режим "остановить и копировать".




============================
Логический оператор SWITCH
============================

Если в case используется return то употреблять brake в секции не надо.

public static Instrument choose() {
        switch(random.nextInt(5)) {
            default : return null;
            case 0 : return new Wind();
            case 1 : return new Percussion();
            case 2 : return new Stringer();
            case 3 : return new Brass();
            case 4 : return new Woodwind();


В другом случае, в секции нужно применять brake;


public static Instrument choose() {
        Instrument i;
	switch(random.nextInt(5)) {
            default : i = null; brake;
            case 0 : i = new Wind(); break;
            case 1 : i = new Percussion(); break;
            case 2 : i = new Stringer(); break;
            case 3 : i = new Brass(); break;
            case 4 : i = new Woodwind(); break;
	}
	
	return i;


========================
this
========================

Обычно, при употреблении this подразумивается "этот объект" или "текущий объект", 
и само слово является ссылкой на текущий объект. В конструкторе, ключевое слово this 
имеет другой смысл: при использовании его со списком аргументов this(int i, String s)
вызывается конструктор, соответствующий данному списку. Также слово this может
использоваться в теле метода или конструктора. Если в списке аргументов переменная
имеет одинаковый тип и имя с одним из полей this указывает на самого себя

class nameClass {
	private double x;

	nameClass(double x) { this.x = x }
}



========================
ЦИКЛ:
========================

Оператор brake завершает цикл, при этом оставшиеся операторы цикла не выполняются.
Оператор continue останавливает выполнение текущей итерации (повтора) цикла и 
переходит к началу цикла.





========================
equals()
========================

Большенство классов библиотек Java переопределают метод equals() по своему, сравнивая
содержимое объектов, а не ссылки на них. Если создаётся новый класс и нужно сравнить 
содержание двух объектов этого класса то, следует переопределить метод equals() и hashCode(), 
т.к. по умолчанию этот метод будет сравнивает ссылки.




========================
Пакет как библиотечный модуль.
========================


packeage access.mypackage;
public class MyClass {
}


import access.mypackage.*;


имя пакета - его каталог, т.е. MyClass.java должен находится в поддиректории \access\mypackage\ от основного файла.
Для правильной компиляции нужно создать CLASSPATH в переменные среды Windows, где указать путь не к пакету, а к основному файлу, который компилируется.


================================================
Пакет как библиотечный модуль - Конфликты имён
================================================


при импортировании конструкции .* двух библиотек, имеющих в своём
составе одинаковые имена классов Vector, например

import net.mindview.simple.*;
import java.util.*;

т.к. второй пакет содержит в себе тот же класс с именем Vector, может привести к
потенциальному конфликту. Конфликт произойдёт при попытки создать объект

Vector vector = new Vector();

Компилятор не знает к какому классу относиться комманда. Нужно уточнить и
записать полностью имя класса с именем библиотеки

java.util.Verctor vector = new java.util.Vector();









int[] a = {1, 2, 3, 4, 5};
System.out.println(Arrays.toString(a));



========================
Тернарный оператор: 
========================

переменная = условие ? выражение1 : выражение2

Если условие выдаёт истенный результат (true), переменной присваивается выражение1, 
если false переменной присваивается выражение2




========================
КОНКАТЕНАЦИЯ:
========================

System.out.println("a =" + a)  
плюс в данном случае означает конкатенацию (объединение строк).




========================
ИНКРЕМЕНТ, ДЕКРЕМЕНТ
========================

Для префиксного декремента и инкремента (++i, --i) 
сначала выполняется операция, а затем выдаётся результат.

Для постфиксной записи (i++, i--) 
сначала выдаётся значение, и лишь затем выполняется операция.




========================
Присваивание:
========================

Примитивные типы хранят данные, а не ссылку на объект 
(int a = 5, int b = a, a = 3) смена данных a не влияют на b.

С объектами или массивами примитивного типа иначе, если взять два разных 
экземпляра класса и, одну ссылку присвоить второй a = b то, обе ссылки 
будут ссылаться на один и тотже объект. Второй объект останется в памяти
и через время будет очищен сборщиком мусора. Такой феномен называется синонимией.




========================
КЛАССЫ АДАПТЕРЫ:
========================

Классы-адаптеры представляют собой пустую реализацию интерфейсов-слушателей, имеющих более одного метода.
Чтобы не реализовывать в классе все методы интерфейса, можно унаследовать класс-адаптер и,
переопределить один или несколько необходимых методов.

Всего классов-адаптеров семь. 

Пример:

implements MouseListener = extends MouseAdapter
implements MouseMotionListener = extends MouseMotionAdapter
implements KeyListener = extends KeyAdapter




========================
КЛАССЫ-ОБЁРТКИ
========================



Во многих случаях бывает предпочтительней работать именно с объектами, а не
примитивными типами. Так, например, при использовании коллекций, просто необходимо
значения примитивных типов каким-то образом представлять в виде объектов. Для этих
целей и предназначены так называемые классы-обертки. Для каждого примитивного типа
Java существует свой класс обертки.


Interger, Long, Float, Double, Short, Byte, Character, Void, Boolean



private class KeyHandler extends KeyAdapter {
	
	public void keyTyped(KeyEvent event) {
		char keyChar = event.getKeyChar();
		
		if (Character.isUpperCase(keyChar))
			keyChar = Character.toLowerCase(keyChar);
	}
}

В примере рассматривается внутренний приватный класс обработчик 
нажатия буквенных клавиш. Класс-обёртка помогает вычислить, какого 
регистра является примитивная переменная keyChar. Если вверхнего 
регистра, значит преобразовать её в нижний регистр.



========================
СИГНАТУРА МЕТОДА:
========================

список аргументов, последовательность аргументов и имя метода.





========================
ПЕРЕГРУЗКА МЕТОДОВ 
========================

Два или более методов с одинаковым именем, но с разным списком аргументов (параметрами). Даже если в одном
классе находятся два метода с одинаковыми именами и списком аргументов, но в разной последовательности то
сигнатура у методов будет разная, следовательно, методы будут считатся перегруженными:

void overloadMethod(int i, double d) {}
void overloadMethod(double d, int i) {}



========================
Оператор return
========================

означает два действия, выход из метода и
возврат результата указанного типа.




========================
Память
========================

регистры, стек, куча, постоянная ROM, запоминающие устройства
(примитивные типы и ссылки на объекты занимают стек. 
Объекты располагаются в куче).




========================
КЛЮЧЕВЫЕ СВОЙСТВА ОБЪЕКТА:
========================

ПОВЕДЕНИЕ ОБЪЕКТА - что с ним можно делать и какие методы к нему можно применять.
СОСТОЯНИЕ ОБЪЕКТА - как объект реагирует на применение методов.
СУЩНОСТЬ ОБЪЕКТА - чем данный объект отличается от других, характеризующихся таким же поведением и стостоянием.




========================
Пять основных черт языка:
========================

1) Всё является объектом
2) Программа это группа объектов, указывающих друг-другу, что делать, посредством сообщений.
3) Каждый объект имеет собственную память, состоящую из других объектов. (композиция)
4) У каждого объекта есть тип.
5) Все объекты определённого типа могут получать одинаковые сообщения. (полиморфизм)




===================================================
ОТНОШЕНИЯ МЕЖДУ КЛАССАМИ: 
===================================================

1) АГРЕГИРОВАНИЕ / КОМПОЗИЦИЯ (содержит HAS) -  механизм создания нового класса Order из объектов
существующих классов Item, Account. Класс Order будет содержать экзмпляры классов Item и Account.




2) НАСЛЕДОВАНИЕ (является IS-A) - класс А является подклассом суперкласса Б 
   (каждый менеджер является сотрудником и обратное, что не каждый сотрудник может быть менеджером). 

    class Manager extends Employee




3) ДЕЛЕГИРОВАНИЕ - действие объекта, поручающего выполнение операции другому объекту, вместо того, чтобы выполнить ее самому.



===================================================
ИНТЕРФЕЙСНЫЕ КЛАССЫ: 
===================================================

Interger, Long, Float, Double, Short, Byte, Character, Void, Boolean

Интерфейсные классы являются терминальными. Используются в списочном массиве ArrayList<Integer>, при этом производительность становиться меньше, чем при работе с массивом int[], т.к. каждое значение инкапсулировано внутри объекта.



===================================================
полиморфизм:
===================================================

работа с объектами неизвестных классов, при условии, что они являются наследниками известного класса.


переопределение getSalary() в подклассе Manager (замещение метода) + бонусы к зарплате

 public double getSalary() {
        double baseSalary = super.getSalary(); - вызов метода salary из суперкласса.
        return baseSalary + bonus;



объект подкласса (Manager) можно использовать вместо любого объекта суперкласса называется принцип постановки.

например: Объект подкласса Manager можно присвоить переменной суперкласса


===================================================
ВОСХОДЯЩЕЕ ПРЕОБРАЗОВАНИЕ ТИПОВ КЛАССОВ (UPCASTING)
===================================================


переменная типа Employee может ссылаться как на объект Employee, так и на объект любого подкласса:

Manager manager = new Manager(...);
Employee[] m = new Employee[3];
m[0] = manager;
m[1] = new Manager(...);

      
Восходящее преобразование (upcasting) — это преобразование от типа порожденного класса (от подкласса) к базовому (суперклассу). Такое преобразование допустимо всегда. Это связано с тем, что объект подкласса всегда в себе содержит как свою часть объект суперкласса.




=========================================================
НИСХОДЯЩЕЕ ПРЕОБРАЗОВАНИЕ ТИПОВ КЛАССОВ (DOWNCASTING) 
=========================================================


Employee m = new Manager(...)*


чтобы вызвать метот подкласса, нужно намекнуть, что m = new Manager(...) на самом деле является подклассом, а не суперклассом, но от этого он не потеряет свой тип Employee.


((Manager)m).setBonus(500); 



Employee[] m = new Employee[2];
m[0] = new Employee(...);
m[1] = new Manager(...)*


чтобы переребрать массив суперкласса, нужно проверить все элементы m[i], является ли элемент экземпляром подклассом Manager;

if(m[i] instanceof Manager)
                ((Manager)m[i]).setBonus(500);





=========================================================
ИНИЦИАЛИЗАЦИЯ С НАСЛЕДОВАНИЕМ.
=========================================================

Сначала инициализируются статические поля базового класса, Затем если есть статические поля в подклассе, 
инициализируются они. 

При создании экземляра класса наследника инициализация начинается с обычных полей базового класса, 
затем вызывается коструктор базового класса, после чего инициализируются обычные поля подкласса 
и только после этого происходит вызов конструктора подкласса.

Нужно остеригаться и стараться не вызывать переопределённые методы в конструкторе базового класса при
создании объекта подкласса.




=========================================================
ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
=========================================================

Инициализация переменных примитивного типа или объекта в полях происходит 
автоматически, им присваивается значение по умолчанию. например: 

class Simple {

 int i;      // i = 0;
 boolean b;  // b = false;
 char c      // c = " ";
 String s;   // s = null;
	
}

локальную переменную (в теле объекта) необходимо обязательно инициализировать вручную.




=========================================================
ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ В БЛОКЕ
=========================================================


Если инициализация переменной происходит в блоке то, время жизни переменной
примитивного типа будет закончено сразу после выхода из блока. С объектом
немного по-другому. Время жизни ссылки на объект будет закончено после
выхода из блока, но объект будет существовать в памяти до тех пор пока сборщик мусора
не очистит память.


{
 x = 59; //инициализация примитивного типа в блоке
 String name = new String(); //инициализация объекта в блоке
}



static {                        // блок инициализации для статического поля nextId; Один для всех экземпляров.
   Random random = new Random();
   nextId = random.nextInt(10000);
}



{                               // блок инициализации, создаётся для каждого экземляра отдельно. 
				// неважно какой вызывается перезагруженый конструктор в классе;
   id = nextId;			// стр.145 Философия Java
   nextId++;
}




=========================================================
Спецификатор доступа - 
=========================================================

без спецификатора - доступен только в пределах пакета

public - доступен везде

protected - ограничивает доступ к методу или к полям суперкласса, открывает метод или поля для подкласса в пределах пакета.



======================
Модификатор private
======================

private (для полей) - доступен в пределах класса. 
private (для метода) - доступен в пределах класса, слово final использовать необязательно. В подклассе невозможно будет переопределить метод.
Метод перестаёт являться частью интерфейса базового класса. Одинаковое имя методов в подклассе и в базовом классе не будет являтся переопределением или перегрузкой метода. Это будут два независимых
метода.
private (для внутреннего класса) - доступен в пределах внешнего класса. Создание объекта только через методы внешнего класса.
private (для конструктора) - создание объекта возможно только через статический метод с указанным возвратным типом имени этого класса.

class Apple {
	private Apple() {} //запрещает прямое создание объекта
	static Apple createApple() { return new Apple(); }

}
//** Создание объекта яблоко */
Apple apple = Apple.createApple();




======================
Модификатор final
======================

final class - делает метод или класс терминальным без возможности расширения класса или переопределения метода. Класс лишается наследование.
final для полей (примитивного типа) - устанавливает поле как константу, которую нельзя изменить.
final для полей (ссылка на объект) - когда ссылка будет связана с объектом, она уже не сможет указывать на другой объект.
сам объект при этом может изменяться.
final для полей (не инициализированых) - не инициализируются значениями по умолчанию, такие поля нужно обязательно инициализировать в конструкторе. Как для примитивов, так и для ссылок на объекты.
final в списке аргументов метода - переменная становится терминальной. Доступна для анонимного класса созданного внутри метода. А также, метод не может изменить значение, на которое указывает передаваемая ссылка.

void f(final int i) { //! i++; }    // запрещено; 
int f(final int i) { retun i + 1; } // разрешено; 



static - поле будет существовать в одном единственном экземляре для всех экземпляров. Статические объекты не переопределяются повторно.
static - к внутреннему классу, будет называться вложенным классом.
static - для метода, возможность вызова метода без объекта(экземпляра). Обращаться можно непосредственно через класс имя_класса.имя_метода. Метод не может обращаться к не статичным полям. 



======================
abstract class, method
======================

Абстрактный класс в объектно-ориентированном программировании — базовый класс, который не предполагает создания экземпляров. 
Абстрактные классы реализуют на практике один из принципов ООП - полиморфизма. Абстрактный класс может содержать (и не содержать) абстрактные методы и свойства. Абстрактный метод не реализуется для класса, в котором описан, однако должен быть реализован для его неабстрактных потомков. Абстрактные классы представляют собой наиболее общие абстракции, то есть имеющие. наибольший объем и наименьшее содержание.


abstact - называется метод, для которого заданы параметры и тип возвращаемого значения, но не тело. Абстрактный метод определяется в классах наследниках. Для того чтобы в классе можно было описывать абстрактные методы, сам класс тоже должен быть описан как абстрактный. Объекты абстрактного класса создавать нельзя.



======================
interface, implements
======================

Интерфейс может содержать поля которые автоматически являются public static и final. Поля в интерфейсе не могут быть не инициализированные.
После выхода Java SE 5 пропала надобность объявлять констатны в интерфейсе, т.к. вышло гораздо более мощное и удобное ключевое слово enum. 
Методы в интерфейсе автоматически являются public. При реализации методов интерфейса в классе, они должны быть объявлены с модификатором public. Интерфейс представляет собой нечто большее, чем абстрактный класс, потому что он позволяет реализовывать
подобие "множественного наследования". Главная причина введения в язык интерфейсов это возможность выполнять восходящее 
преобразование к нескольким базовым типам.Вторая причина, использование интерфейсов совпадает с предназначением абстрактных 
классов - запретить программисту-клиенту создание объектов этого класса. Интерфейс может унаследовать несколько интерфейсов.
Любой класс размещённый внутри интерфейса, автоматически является public static (вложенный класс)






try {

} finally {
	x.dispose();
}


Ключевое слово try показывает, что следующий за ним блок (в фигурных скобках) является защищённой секцией.
Код в секции finally выполняется всегда, независимо от того, как прошло выполнение блока try.
Дословно, секция finally означает, чтобы не произошло всегда вызывать метод x.dispose();






есть переменные - они имеют тип (могут хранить [указатель на] объекты некого типа-класса)
есть собственно объект - экземпляр класса, он же кусок выделенной памяти, который содержит поля класса и т.п. 
есть класс - он же тип. описывает поля и методы .




======================
ОБРАТНЫЙ ВЫЗОВ (Callback)
======================

При обратном вызове, программист задаёт действия, которые должны выполняться всякий раз, когда происходит некое событие.





======================
ВНУТРЕННИЙ КЛАСС 
======================
Называется класс, определённый внутри другого класса. Объект внутреннего класса имеет доступ к членам внешнего класса.
Объект внутреннего класса скрывается от классов этого же пакета. Очень удобно использовать обратный вызов. Внешний класс
может создавать в методах или в конструкторе экземпляр внутреннего класса с модификатором private. И имеет доступ к его
методам, но не к полям.





======================
ВЛОЖЕННЫЙ КЛАСС 
======================
внутренний статический класс.
Любой класс размещённый внутри интерфейса, автоматически является public static (вложенный класс) стр.260



======================
ЛОКАЛЬНЫЙ ВНУТРЕННИЙ КЛАСС 
======================
Создание класса в теле метода.




======================
АНОНИМНЫЙ ВНУТРЕННИЙ КЛАСС 
======================
Создание класса у которого отсутствует имя класса и использует для создания класса имя интерфейса.

button.addActionListener(new ActionListener {
        public void actionPerformed(ActionEvent e) {
        }
};

В данном случае, создаётся анонимный класс имя которого используется от интерфейса ActionListener
При использовании имени интерфейса анонимный класс должен в себе реализовать его методы.

Если нужно использовать объекты определённые вне внутреннего класса, например аргументы в методе, 
компилятор требует, чтобы переданные на них ссылки объявлялись неизменными, с модификатором final.




======================
ВНУТРЕННИЙ КЛАСС .new и .this 
======================
Чтобы создать объект внутреннего класса, нужно создать объект внешнего класса и через ссылку на объект 
внешнего класса создать внутренний объект.  

NameOuterClass noc = new NameOuterClass();
NameOuterClass.NameInnerClass nic = oc.new NameInnerClass();

чтобы получить ссылку на объект внешнего класса во внутреннем классе, нужно записать имя внешнего класса 
за которым следуюет ключевое слово this.
 
NameOuterClass.this;





========================
ТИПИЗИРОВАННЫЕ И НЕ ТИПИЗИРОВАННЫЕ КОНТЕЙНЕРЫ:
========================

ArrayList может быть двух видов, 


НЕ ТИПИЗИРОВАННЫЙ ArrayList apple = new ArrayList();

В не типизированный массив, можно помещать объекты разных типов, например
apple.add(new Apple());
apple.add(new Orange());

только перед объявлением не параметризованных типов массива следуюет указать директиву
@SuppressWarnings("uncheked") // подавляются только "непроверяемые" предупреждения
public static void main(String[] args)



ТИПИЗИРОВАННЫЙ ArrayList<Apple> apple = new ArrayList<Apple>();

в типизированный массив можно помещать только объекты объявленного типа или его потомков.




ВАЖНО! Любой контейнер может быть объявлен nтолько одного типа.

List<Shape> c1 = new ArrayList<Shape>();
List<Shape> c2 = new ArrayList<Triangle>(); - неправильно! Сужение типа контейнера невозможно. Ошибка компиляции.




class nameOfClass<T> - Суффикс <T> сообщает компилятору, что тип является параметризованным 
по типу T - при использовании класса на место T будет подставлен фактический тип.



Arrays.asList(); - метод получает ссылку на массив, либо список элементов раздельных запятыми,
и преобразует его в объект List.


Можно использовать вывод Arrays.asList() на прямую, в виде List, но в этом случае, нижележащим
представлением будет массив, не допускающий изменения размеров. Вызов add(); или delete();
для такого списка приведёт к попытке изменения размера массива, а это приведёт к ошибке во 
время выполнения:

List<Integer> list = new Arrays.asList(16, 17, 18, 19, 20);
list.add(21); // ошибка времени выполнения нижележащий массив не должен изменяться в размерах.




Collections.addAll(); - получает объект Collection и, массив либо список разделённый запятыми. 
и добовляет элементы в Collection.



HashSet, HashMap - минимальное время выроботки элементов, хаотичный порядок.
Treeset, TreeMap - храняться отсортированными по возрастанию в порядке сравнения
-LinkedHashSet, LinkedHashMap - хранение элементов в порядке добавления 





========================
ОСНОВНЫЕ КОНЦЕПЦИИ ХРАНЕНИЯ ОБЪЕКТОВ В КОНТЕЙНЕРЕ
========================

В библиотеке контейнеров Java проблема хранения объектов делится на две концепции
выраженные в виде базовых интерфейсов.



***КОЛЛЕКЦИЯ - Корневой интерфейс, описывающий общую функциональность всех последовательных контейнеров.


**интерфейс List(список) хранит элементы в порядке вставки. 


Контейнеры List гарантируют определённый порядок следования элементов. Интерфейс List расширяет
базовый интерфейс Collection несколькими методами, обеспечивающими вставку и удаление элементов 
в середине списка. Существует две основные разновидности List:

*контейнер ArrayList, опимизирован для произвольного доступа к элементам, но с 
относительно медленными оперерациями вставки/удаления элементов в середине списка.

*контейнер LinkedList, оптимизирован для последовательного доступа к элементам, с быстрыми 
операциями вставки/удаления элементов в середине списка. Произвольный доступ к элементам LinkedList
выполняется относительно медленно, но по широте возможностей он превосходит ArrayList.
Класс LinkedList также содержит методы, позволяющие использовать его в качестве стека, или очереди Queue.

Методы getFirst() и element() идентичны, они возвращают начало (первый элемент) списка без его удаления
и выдают NoSuchElementException для пустого списка. 
peek() представляет собой небольшую модификацию этих двух методов. Он возращает null для пустого списка 
addFirst() вставляет элемент вначало списка.
Метод offer() делает тоже самое, что и методы add() и addLast() - добавляет элемент в конец списка.
removeLast() удаляет и возвращает последний элемент списка. 



**интерфейс Set(множество) в котором нельзя хранить повторяющиеся элементы.


В множествах Set каждое значение может храниться только в одном экземпляре. Попытки добавить 
новый экземпляр эквивалентного объекта блокируются. Множества часто используются для проверки
принадлежности, чтобы можно было легко проверить, принадлежит ли объект заданному множеству.
Важнейшей операцией Set является операция поиска, поэтому на практике обычно выбирается реализация
HashSet, оптимизированная для быстрого поиска.

*HashSet - минимальное время выборки элементов, хаотичный порядок.
*Treeset - хряняться отсортированными в порядке возрастания.
*LinkedHashSet - элементы хранятся в порядке добавления.




**интерфейс Queue(очередь) - очередь обычно представляет собой контейнер, работающий по принципу 
"первый зашёл, первый вышел" (FIFO). Элементы заносяться в очередь с одного "конца" и извлекаются с
другого в порядке их поступления. (принцип работы мясорубки)
Класс LinkedList содержит методы, поддерживающие поведение очереди, и реализует интерфейс Queue, поэтому
LinkedList может использоваться в качестве реализации Queue.

Метод offer() вставляет элемент в конец очереди, если вставка невозможна, возвращает false.
peek() и element() возвращают начальные элемент без его удаления из очереди. peek() для пустой очереди
возвращает null, а element() выдаёт исключение NoSuchElementException.
Методы poll() и remove() удаляют и возращают начальный элемент очереди, но poll() для пустой очереди
возвращает null, remove() выдаёт NoSuchElementException();


*PriorityQueue - в приоритетной очереди следующим элементом считается элемент, обладающий наивысшим
приоритетом.



***КАРТА - набор пар объектов "ключ-значение", с возможностью выборки по ключу. 


ArrayList позволяет искать объекты по порядковым номерам, поэтому в каком-то смысле он связывает 
числа с объектами. 

**интерфейс Map (карта - встречаются термины ассоциативный массив и словарь) позволяет искать объекты
по другим объектам - например, получить объект значения по объекту ключа, по аналогии с поиском
определения по слову. В контейнерах Map храняться два объекта: ключ и связанное с ним значение.




В контейнере Map, объект ключа должен быть уникальный. 

HashMap<String, String> hmap = new HashMap<String, String>(
map.put("dog","Bosco");
map.put("dog","Spot");
System.out.print(hmap.get("dog"));


Иначе, при вызове элемента по ключу, значене будет выдаваться последнего элемента в последовательности.





*HashMap - оптимизированы для быстрого доступа.
*TreeMap - хранит ключи в отсортированном порядке.
*LinkedHashMap - элементы хранятся в порядке вставки.


========================
ИТЕРАТОР, Iterator
========================

Объект обеспечивающий перемещение по последовательности объектов с выбором каждого объекта этой последовательности,
при этом программисту-клиенту не надо знать или заботиться о лежащей в ее основе структуре.(стр 288)
Iterator в Java поддерживает перемещение только в одном направлении.


* Запросить у контейнера итератор можно вызовом метода iterator(). Полученный итератор готов вернуть начальный элемент последовательности при первом вызове своего метода next();
* Получить следующий элемент последовательности вызовом метода next();
* Проверить остались ли ещё объекты в последовательности (метод hasNext())
* Удалить из последовательности последний элемент, возвращенный интератором, можно использовать метод remove();	


========================
ИТЕРАТОР, ListIterator 
========================

ListIterator - более мощная разновидность Iterator, поддерживаемая только классами List. Если Iterator 
поддерживает перемщение только вперёд ListIterator является двухсторонним.


========================
Iterable, foreach
========================

Синтаксис foreach будет работать с любым объектом Сollection. 

Collection<String> ch = new LinkedList<String>();
        Collections.addAll(ch, "Take the long way home".split(" "));
        for(String s : ch) 
            System.out.print(" '" + s + "' ");

поскольку ch является Collection пример показывает что поддержка foreach является характеристикой всех 
контейнеров Collection. Работа этой конструкции объясняется тем, что в Java SE5 появился новый интерфейс
Iterable, который содержит метод iterator() для создания Iterator, и именно интерфейс Iterable
используется в переборке последовательности в синтаксисе foreach. Следовательно, создав любой класс,
реализующий Iterable, вы сможете использовать его в синтаксисе foreach. (стр 304)




========================
СТЕК
========================

Стек называют контейнером работающим по принципу первый вошёл последним вышёл (LIFO).
Контейнер LinkedList имеет методы, напрямую связан с реализацией функциональности стека.
Метод addFirst() размещает элемент первым списке.
Метод removeFirst() удаляет и возвращает верхний элемент.
0Таким образом, два метода работают в последовательности с элементами.


public class Stack<T> {
    private LinkedList<T> storage = new LinkedList<T>();

    public void push(T incoming) { storage.addFirst(incoming); }

    public boolean empty() { return storage.isEmpty(); }

    public T peek() { return storage.getFirst(); }
    public T pop() { return storage.removeFirst(); }
}




========================
try
========================

try - перехватчик исключения
защищённая секция - область программы, в которой могут произойти исключения (блок try) за которой следует
специальный блок, отвечающий за обработку этих исключений. (секция catch)




========================
catch
========================

обработчик исключения, создаётся для каждого исключения, которое нужно перехватить. Обработчики всегда
следуют прямо за блоком try. При возникновении исключения механизм обработки исключений ищет первым из обработчиков
исключений, аргумент которого соотвествует текущему типу исключения. После этого он передаёт управление в блок catch,
и таким образом исключение считается обработанным. После предложения catch поиск обработчиков исключений прекращается.




========================
Модель прерывания
========================

Предполагает, что ошибка настолько серьёзна, что при возникновении исключения продолжить исполнение невозможно. Кто бы
ни возбудил исключение,  сам факт его выдачи означает, что исправить ситуацию "на месте" невозможно и возвращать управление
обратно не нужно.



========================
Альтернативная модель возобновление
========================

Подразумевает, что обработчик ошибок сделает что-то для исправления ситуации, после чего предпринимается попытка повторить
неудавшуюся операцию в надежде на успешный исход. В таком случае исключение больше напоминает вызов метода - чтобы применить
модель возобновления в Java, придётся пойти именно по этому пути (т.е. не возбуждать исключение, а вызвать метод, способный
решить проблему). Также можно создать блок try внутри цикла while, который станет снова и снова обращаться к этому блоку,
пока не будет достигнут нужный результат.



========================
throws спецификация исключений
========================

В Java дабавили в синтаксис (ОБЯЗАТЕЛЬНЫЙ для использования) при помощи которого сообщается клиенту об исключениях,
возбуждаемых методом, чтобы клиент сумел правильно обработать их. Этот синтаксис называется спецификацией исключений,
входит в объявление метода и следуюет сразу за списком агрументов.
Спецификация исключений состоит из ключевого слова throws, за которым перечисляются все возможные типы исключений. 
Обойти спецификацию исключений невозможно. Если метод возбуждает исключения и не обрабатывает их, компилятор предложит
либо обработать исключение, либо включить его в спецификацию. Жестким контролем за соблюдением правил сверху донизу
Java гарантирует правильность использования механизма исключений во время компиляции программы.


========================
checked - контролируемые исключения
========================

Исключения, которые проверяются и навязываются ещё на этапе компиляции программы, называю контролируемые.



========================
Произвольные исключения
========================

Универсальный обработчик, перехватывающий любые типы исключения. Осуществляется перехватом базового класса всех исключений
Exception (существуют и другие базовые типы исключений, но класс Exception является базовым практически для всех программных
исключительных ситуаций:

catch(Exception e) {
	System.out.println("Перехвачено исключение");
}

Подобная конструкция не пропустит ни одного исключения, поэтому её следуюет размещать в самом конце списка обработчиков, во
избежание блокировки следующих за ней обработчиков исключений.
Exception не предоставит никакой полезной информации об исключительной ситуации, но можно вызвать методы из его базового типа
Throwable:

* String getMessage(), String getLocalizedMessage() возвращают подробноее сообщение об ошибке (или сообщение, локализованное
для текущего контекста).
* String toString() возвращает короткое описание объекта Throwable, включая подробное сообщение, если оно присутствует.
* void PrintStackTrace(), void PrinStackTrace(PrintStream), void PrintStackTrace(java.io.PrintWriter) выводят информацию
об объекте Throwable и трассировку стека вызовов для этого объекта. Трассировка стека вызовов показывает последовательность
вызова методов, которая привела к точке возникновения исключения. Первый вариант отправляет информацию в стандартный  поток
ошибок, второй и третий - в поток по вашему выбору. 
* Throwable fillInStackTrace() записывает в объект Throwable информацию о текущем состоянии стека. Метод используется при 
повторном возбуждении ошибок или исключений.


========================
Трассировка стека
========================

Информацию предоставляемую методом printStackTrace(), также можно получить напрямую вызовом getStackTrace(). метод возвращает
массив элементов трассировки, каждый из которых представляет один кадр стека. Нулевой элемент предоставляет вершину стека, то 
есть последний вызванный метод последовательности (точка, в которой был создан и инициализирован объект Throwable).
Соответственно, последний элемент массива представляет "низ" стека, то есть первый вызванный элемент последовательности. 



========================
Повторное возбуждение исключения
========================

В некоторых ситациях требуется заново возбудить уже перехваченное исключение; чаще всего это происходит при использовании
Exeption для перехвата всех исключений. Т.к. ссылка на текущее исключение уже имеется попросту возбуждается исключение
по этой ссылке:

catch(Exeption e) {
	System.out.println("Было возбуждено исключение");
	throw e;
}






=========================================================
КОВАРИАНТНОСТЬ ВОЗВРАЩАЕМЫХ ТИПОВ -
=========================================================

Переопределенный метод подкласса может вернуть тип, производный от типа, возвращаемого методом базового класса.

Главное отличие Java SE 5 от предыдущих версий Java заключается в том, что старые версии Java заставляли 
переопределённый метод process() возвращать Grain тип вместо Wheat, хотя тип Wheat, производный от Grain, является
допустимым возращаемым типом. Ковариантность, возвращаемых типов позволяет вернуть более специализированный тип Wheat.



class Grain {
    public String toString() { return "Grain"; }
}
class Wheat extends Grain {
    public String toString() { return "Wheat"; }
}
class Mill {
    Grain process() { return new Grain(); }
}
class WheatMill extends Mill {
    Wheat process() { return new Wheat();}
}

public class CovariantReturn {
    public static void main(String[] main) {
        Mill m = new Mill();
        Grain g = m.process();
        System.out.println(g);
        m = new WheatMill();
        g = m.process();
        System.out.println(g);
    }
}
	
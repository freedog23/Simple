========================
СИСТЕМА УПРАВЛЕНИЯ ВЕРСИЯМИ
========================

GIT 
http://progit.org/book/ru/

SUBVERSION
http://svnbook.red-bean.com/nightly/ru/svn-book.html




========================
TOMCAT смена пароля
========================

conf/tomcat-users.xml to add these lines:

<role rolename="manager-gui" />
<user username="tomcat" password="mypasswordhere" roles="manager-gui"/>



========================
СБОРЩИК МУСОРА
========================

Сборщик мусора в Java работает в адаптивном режиме.
Сначала работает в режиме "пометить и убрать", если
появляется излишняя фрагментация кучи то, переходит
в режим "остановить и копировать".




============================
Логический оператор SWITCH
============================

Если в case используется return то употреблять brake в секции не надо.

public static Instrument choose() {
        switch(random.nextInt(5)) {
            default : return null;
            case 0 : return new Wind();
            case 1 : return new Percussion();
            case 2 : return new Stringer();
            case 3 : return new Brass();
            case 4 : return new Woodwind();


В другом случае, в секции нужно применять brake;


public static Instrument choose() {
        Instrument i;
	switch(random.nextInt(5)) {
            default : i = null; brake;
            case 0 : i = new Wind(); break;
            case 1 : i = new Percussion(); break;
            case 2 : i = new Stringer(); break;
            case 3 : i = new Brass(); break;
            case 4 : i = new Woodwind(); break;
	}
	
	return i;


========================
equals()
========================

Спецификация языка Java требует чтобы метод equals() обладал следующими характеристиками.

1) Рефлекснивность - для либой не нулевой ссылки x вызов x.equals(x) должен возвращать значение true

2) Симметричность - для любых ссылок x и y вызов x.euqals(y) должен возвращать значение true тогда и 
только тогда, когда y.equals(x) возвращает true

3) Транзитивность - для любых ссылок x, y и z, если вызовы x.equals(y) и y.equals(z) возвращают значение
true, вызов x.equals(z) должен возвращать значение true.

4) Согласованность - если объекты на которые ссылались переменные x и y не изменяются, то повторный вызов
x.equals(y) должен возвращать тоже значение

5) для любой null-ссылки x вызов x.equals(null) должен возвращать значение false


Пример переопределённого метода euqals() для сравнения двух объектов по содержимому

Employee men = new Employee("Jhon", 10000);
Employee women = new Employee("Sara", 10000);

men.equals(women);


public boolean euqals(Object other) {

    if(this == other) return true;
    if(other == null) return false;
    if(getClass() != other.getClass()) return false;

    Employee employee = (Employee)other;
    
    return name == employee.name 
        && salary == salary.other; 
}


========================
Клонирование объектов Clonable
========================

Если нужно создать точную копию объетка у которого все поля являются числовыми такое клонирование выполняется
прекрасно. Получается два независимых объекта друг от друга. Такое клонирование называется поверхностным.

public class Simple {

    private Integer i;

    Simple(int i) { this.i = i; }
    
    public static void main(String[] args) throws CloneNotSupportedException {
        Simple simple1 = new Simple(5);
        Simple simple2 = (Simple)simple1.clone();

    }
}

однако, если в полях класса есть ссылки на другие объекты не immutable (String) и не числовые, допустим Date hireDay;

public class Employee implements Clonable {
   private String name;
   private double salary;
   private Date hireDay;
}

в таком случае, нужно делать глубокое клонирование объекта. Класс должен реализовать интерфейс Clonable и переопределить
в себе метод clone(). Далее, необходимо произвести поверхностное клонирование объекта, затем в дубликат клонировать отдельное
поле.

@Override
public Employee clone() throws CloneNotSupportedException {
    Employee cloned = (Employee)super.clone();
    cloned.hireDay = (Date)hireDay.clone();
    return cloned;    

}



========================
this
========================

Обычно, при употреблении this подразумивается "этот объект" или "текущий объект", 
и само слово является ссылкой на текущий объект. В конструкторе, ключевое слово this 
имеет другой смысл: при использовании его со списком аргументов this(int i, String s)
вызывается конструктор, соответствующий данному списку. Также слово this может
использоваться в теле метода или конструктора. Если в списке аргументов переменная
имеет одинаковый тип и имя с одним из полей this указывает на самого себя

class nameClass {
	private double x;

	nameClass(double x) { this.x = x }
}



========================
ЦИКЛ:
========================

Оператор brake завершает цикл, при этом оставшиеся операторы цикла не выполняются.
Оператор continue останавливает выполнение текущей итерации (повтора) цикла и 
переходит к началу цикла.





========================
equals()
========================

Большенство классов библиотек Java переопределают метод equals() по своему, сравнивая
содержимое объектов, а не ссылки на них. Если создаётся новый класс и нужно сравнить 
содержание двух объектов этого класса то, следует переопределить метод equals() и hashCode(), 
т.к. по умолчанию этот метод будет сравнивает ссылки.




========================
Пакет как библиотечный модуль.
========================


packeage access.mypackage;
public class MyClass {
}


import access.mypackage.*;


имя пакета - его каталог, т.е. MyClass.java должен находится в поддиректории \access\mypackage\ от основного файла.
Для правильной компиляции нужно создать CLASSPATH в переменные среды Windows, где указать путь не к пакету, а к основному файлу, который компилируется.


================================================
Пакет как библиотечный модуль - Конфликты имён
================================================


при импортировании конструкции .* двух библиотек, имеющих в своём
составе одинаковые имена классов Vector, например

import net.mindview.simple.*;
import java.util.*;

т.к. второй пакет содержит в себе тот же класс с именем Vector, может привести к
потенциальному конфликту. Конфликт произойдёт при попытки создать объект

Vector vector = new Vector();

Компилятор не знает к какому классу относиться комманда. Нужно уточнить и
записать полностью имя класса с именем библиотеки

java.util.Verctor vector = new java.util.Vector();









int[] a = {1, 2, 3, 4, 5};
System.out.println(Arrays.toString(a));



========================
Тернарный оператор: 
========================

переменная = условие ? выражение1 : выражение2

Если условие выдаёт истенный результат (true), переменной присваивается выражение1, 
если false переменной присваивается выражение2




========================
КОНКАТЕНАЦИЯ:
========================

System.out.println("a =" + a)  
плюс в данном случае означает конкатенацию (объединение строк).




========================
ИНКРЕМЕНТ, ДЕКРЕМЕНТ
========================

Для префиксного декремента и инкремента (++i, --i) 
сначала выполняется операция, а затем выдаётся результат.

Для постфиксной записи (i++, i--) 
сначала выдаётся значение, и лишь затем выполняется операция.




========================
Присваивание:
========================

Примитивные типы хранят данные, а не ссылку на объект 
(int a = 5, int b = a, a = 3) смена данных a не влияют на b.

С объектами или массивами примитивного типа иначе, если взять два разных 
экземпляра класса и, одну ссылку присвоить второй a = b то, обе ссылки 
будут ссылаться на один и тотже объект. Второй объект останется в памяти
и через время будет очищен сборщиком мусора. Такой феномен называется синонимией.




========================
КЛАССЫ АДАПТЕРЫ:
========================

Классы-адаптеры представляют собой пустую реализацию интерфейсов-слушателей, имеющих более одного метода.
Чтобы не реализовывать в классе все методы интерфейса, можно унаследовать класс-адаптер и,
переопределить один или несколько необходимых методов.

Всего классов-адаптеров семь. 

Пример:

implements MouseListener = extends MouseAdapter
implements MouseMotionListener = extends MouseMotionAdapter
implements KeyListener = extends KeyAdapter




========================
КЛАССЫ-ОБЁРТКИ
========================



Во многих случаях бывает предпочтительней работать именно с объектами, а не
примитивными типами. Так, например, при использовании коллекций, просто необходимо
значения примитивных типов каким-то образом представлять в виде объектов. Для этих
целей и предназначены так называемые классы-обертки. Для каждого примитивного типа
Java существует свой класс обертки.


Interger, Long, Float, Double, Short, Byte, Character, Void, Boolean



private class KeyHandler extends KeyAdapter {
	
	public void keyTyped(KeyEvent event) {
		char keyChar = event.getKeyChar();
		
		if (Character.isUpperCase(keyChar))
			keyChar = Character.toLowerCase(keyChar);
	}
}

В примере рассматривается внутренний приватный класс обработчик 
нажатия буквенных клавиш. Класс-обёртка помогает вычислить, какого 
регистра является примитивная переменная keyChar. Если вверхнего 
регистра, значит преобразовать её в нижний регистр.



========================
КЛАССЫ-ОБЁРТКИ (АВТОУПАКОВКА)
========================

Дано:
ArrayList<Integer> list = new ArrayList<Integer>();

Выражение:
list.add(3)

автоматически преобразуется в выражение:
list.add(new Integer(3));

подобное автоматическое преобразование называется автоупаковкой.


Спецификация автоупаковки требует, чтобы значения boolean, byte, char было меньше 127,
а также short и int -128 127, т.е.

Integer a = 128;
Integer b = 128;
Integer c = 100;
Integer d = 100;
System.out.println(a == b + " " + c == d) // выдаст false и true
a и b превышает допустимое значения. Для сравнения больших чисел надо использовать метод equals();



========================
СИГНАТУРА МЕТОДА:
========================

список аргументов, последовательность аргументов и имя метода.





========================
ПЕРЕГРУЗКА МЕТОДОВ 
========================

Два или более методов с одинаковым именем, но с разным списком аргументов (параметрами). Даже если в одном
классе находятся два метода с одинаковыми именами и списком аргументов, но в разной последовательности то
сигнатура у методов будет разная, следовательно, методы будут считатся перегруженными:

void overloadMethod(int i, double d) {}
void overloadMethod(double d, int i) {}



========================
МЕТОДЫ С ПЕРЕМЕННЫМ ЧИСЛОМ ПАРАМЕТРОВ
========================

Многоточие double... означает, что можно указывать любое количество аргументов.

public static double max(double... values) {}

Вызов функции:

double m = max(3.1, 40.4, -5)

Компилятор  передает методу max() эквивалетное выражене new double[] {3.1, 40.4, -5}


========================
Оператор return
========================

означает два действия, выход из метода и
возврат результата указанного типа.




========================
Память
========================

регистры, стек, куча, постоянная ROM, запоминающие устройства
(примитивные типы и ссылки на объекты занимают стек. 
Объекты располагаются в куче).




========================
КЛЮЧЕВЫЕ СВОЙСТВА ОБЪЕКТА:
========================

ПОВЕДЕНИЕ ОБЪЕКТА - что с ним можно делать и какие методы к нему можно применять.
СОСТОЯНИЕ ОБЪЕКТА - как объект реагирует на применение методов.
СУЩНОСТЬ ОБЪЕКТА - чем данный объект отличается от других, характеризующихся таким же поведением и стостоянием.




========================
Пять основных черт языка:
========================

1) Всё является объектом
2) Программа это группа объектов, указывающих друг-другу, что делать, посредством сообщений.
3) Каждый объект имеет собственную память, состоящую из других объектов. (композиция)
4) У каждого объекта есть тип.
5) Все объекты определённого типа могут получать одинаковые сообщения. (полиморфизм)




===================================================
ОТНОШЕНИЯ МЕЖДУ КЛАССАМИ: 
===================================================

1) АГРЕГИРОВАНИЕ / КОМПОЗИЦИЯ (содержит HAS) -  механизм создания нового класса Order из объектов
существующих классов Item, Account. Класс Order будет содержать экзмпляры классов Item и Account.




2) НАСЛЕДОВАНИЕ (является IS-A) - класс А является подклассом суперкласса Б 
   (каждый менеджер является сотрудником и обратное, что не каждый сотрудник может быть менеджером). 

    class Manager extends Employee




3) ДЕЛЕГИРОВАНИЕ - действие объекта, поручающего выполнение операции другому объекту, вместо того, чтобы выполнить ее самому.



===================================================
ИНТЕРФЕЙСНЫЕ КЛАССЫ: 
===================================================

Interger, Long, Float, Double, Short, Byte, Character, Void, Boolean

Интерфейсные классы являются терминальными. Используются в списочном массиве ArrayList<Integer>, при этом производительность становиться меньше, чем при работе с массивом int[], т.к. каждое значение инкапсулировано внутри объекта.



===================================================
полиморфизм:
===================================================

работа с объектами неизвестных классов, при условии, что они являются наследниками известного класса.


переопределение getSalary() в подклассе Manager (замещение метода) + бонусы к зарплате

 public double getSalary() {
        double baseSalary = super.getSalary(); - вызов метода salary из суперкласса.
        return baseSalary + bonus;



объект подкласса (Manager) можно использовать вместо любого объекта суперкласса называется принцип постановки.

например: Объект подкласса Manager можно присвоить переменной суперкласса


Полиморфизм не распространяется на статические методы или переменные.


===================================================
ВОСХОДЯЩЕЕ ПРЕОБРАЗОВАНИЕ ТИПОВ КЛАССОВ (UPCASTING)
===================================================


переменная типа Employee может ссылаться как на объект Employee, так и на объект любого подкласса:

Manager manager = new Manager(...);
Employee[] m = new Employee[3];
m[0] = manager;
m[1] = new Manager(...);

      
Восходящее преобразование (upcasting) — это преобразование от типа порожденного класса (от подкласса) к базовому (суперклассу). Такое преобразование допустимо всегда. Это связано с тем, что объект подкласса всегда в себе содержит как свою часть объект суперкласса.




=========================================================
НИСХОДЯЩЕЕ ПРЕОБРАЗОВАНИЕ ТИПОВ КЛАССОВ (DOWNCASTING) 
=========================================================


Employee m = new Manager(...)*


чтобы вызвать метот подкласса, нужно намекнуть, что m = new Manager(...) на самом деле является подклассом, а не суперклассом, но от этого он не потеряет свой тип Employee.


((Manager)m).setBonus(500); 



Employee[] m = new Employee[2];
m[0] = new Employee(...);
m[1] = new Manager(...)*


чтобы переребрать массив суперкласса, нужно проверить все элементы m[i], является ли элемент экземпляром подклассом Manager;

if(m[i] instanceof Manager)
                ((Manager)m[i]).setBonus(500);



=========================================================
ПОРЯДОК ИНИЦИАЛИЗАЦИИ КЛАССА
=========================================================

1) Инициализируются статические поля и статические блоки
2) Все поля инициализируются значениями по умолчанию
3) Инициализация полей и инициализационные блоки выполняются в порядке их следования в классе
4) Если в первой строчке конструктора вызывается другой конструктор, то выполняется вызванный конструктор
5) Выполяется тело конструктора


=========================================================
ИНИЦИАЛИЗАЦИЯ С НАСЛЕДОВАНИЕ (В ПРОЦЕССЕ ДОРОБОТКИ)
=========================================================

Сначала инициализируются статические поля базового класса, Затем если есть статические поля в подклассе, 
инициализируются они. 

При создании экземляра класса наследника инициализация начинается с конструктора базового класса, затем
инициализируются поля базового класса, после чего вызывается коструктор класса потомка, затем
инициализируются обычные поля подкласса.

Нужно остеригаться и стараться не вызывать переопределённые методы в конструкторе базового класса при
создании объекта подкласса.




=========================================================
ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
=========================================================

Инициализация переменных примитивного типа или объекта в полях происходит 
автоматически, им присваивается значение по умолчанию. например: 

class Simple {

 int i;      // i = 0;
 boolean b;  // b = false;
 char c      // c = " ";
 String s;   // s = null;
	
}

локальную переменную (в теле объекта) необходимо обязательно инициализировать вручную.




=========================================================
ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ В БЛОКЕ
=========================================================


Если инициализация переменной происходит в блоке то, время жизни переменной
примитивного типа будет закончено сразу после выхода из блока. С объектом
немного по-другому. Время жизни ссылки на объект будет закончено после
выхода из блока, но объект будет существовать в памяти до тех пор пока сборщик мусора
не очистит память.


{
 x = 59; //инициализация примитивного типа в блоке
 String name = new String(); //инициализация объекта в блоке
}



static {                        // блок инициализации для статического поля nextId; Один для всех экземпляров.
   Random random = new Random();
   nextId = random.nextInt(10000);
}



{                               // блок инициализации, создаётся для каждого экземляра отдельно. 
				// неважно какой вызывается перезагруженый конструктор в классе;
   id = nextId;			// стр.145 Философия Java
   nextId++;
}




=========================================================
Модификатор доступа - 
=========================================================

без спецификатора - доступен только в пределах пакета

public - доступен везде

protected - ограничивает доступ к методу или к полям суперкласса, открывает метод или поля для подкласса в пределах пакета.



======================
Модификатор private
======================

private (для полей) - доступен в пределах класса. 
private (для метода) - доступен в пределах класса, слово final использовать необязательно. В подклассе невозможно будет переопределить метод.
Метод перестаёт являться частью интерфейса базового класса. Одинаковое имя методов в подклассе и в базовом классе не будет являтся переопределением или перегрузкой метода. Это будут два независимых
метода.
private (для внутреннего класса) - доступен в пределах внешнего класса. Создание объекта только через методы внешнего класса.
private (для конструктора) - создание объекта возможно только через статический метод с указанным возвратным типом имени этого класса.

class Apple {
	private Apple() {} //запрещает прямое создание объекта
	static Apple createApple() { return new Apple(); }

}
//** Создание объекта яблоко */
Apple apple = Apple.createApple();




======================
Модификатор final
======================

final class - делает метод или класс терминальным без возможности расширения класса или переопределения метода.
Класс лишается наследование.
final для полей (примитивного типа) - устанавливает поле как константу, которую нельзя изменить.
final для полей (ссылка на объект) - когда ссылка будет связана с объектом, она уже не сможет указывать на другой объект.
сам объект при этом может изменяться.
final для полей (не инициализированых) - не инициализируются значениями по умолчанию, такие поля нужно обязательно 
инициализировать в конструкторе. Как для примитивов, так и для ссылок на объекты.
final в списке аргументов метода - переменная становится терминальной. Доступна для анонимного класса созданного внутри метода.
А также, метод не может изменить значение, на которое указывает передаваемая ссылка.

void f(final int i) { //! i++; }    // запрещено; 
int f(final int i) { retun i + 1; } // разрешено; 



static - поле будет существовать в одном единственном экземляре для всех экземпляров. Статические объекты не переопределяются повторно.
static - к внутреннему классу, будет называться вложенным классом.
static - для метода, возможность вызова метода без объекта(экземпляра). Обращаться можно непосредственно через класс имя_класса.имя_метода. Метод не может обращаться к не статичным полям. 



======================
abstract class, method
======================

Абстрактный класс в объектно-ориентированном программировании — базовый класс, который не предполагает создания экземпляров. 
Абстрактные классы реализуют на практике один из принципов ООП - полиморфизма. Абстрактный класс может содержать (и не содержать)
абстрактные методы и свойства. Абстрактный метод не реализуется для класса, в котором описан, однако должен быть реализован для
его неабстрактных потомков. Абстрактные классы представляют собой наиболее общие абстракции, то есть имеющие. наибольший объем
и наименьшее содержание.


abstact - называется метод, для которого заданы параметры и тип возвращаемого значения, но не тело. Абстрактный метод определяется в классах наследниках. Для того чтобы в классе можно было описывать абстрактные методы, сам класс тоже должен быть описан как абстрактный. Объекты абстрактного класса создавать нельзя.



======================
interface, implements
======================

Интерфейс может содержать поля которые автоматически являются public static и final. Поля в интерфейсе не могут быть
 не инициализированные. После выхода Java SE 5 пропала надобность объявлять констатны в интерфейсе, т.к. вышло гораздо
более мощное и удобное ключевое слово enum. 
Методы в интерфейсе автоматически являются public. При реализации методов интерфейса в классе, они должны быть объявлены
с модификатором public. Интерфейс представляет собой нечто большее, чем абстрактный класс, потому что он позволяет реализовывать
подобие "множественного наследования". Главная причина введения в язык интерфейсов это возможность выполнять восходящее 
преобразование к нескольким базовым типам.Вторая причина, использование интерфейсов совпадает с предназначением абстрактных 
классов - запретить программисту-клиенту создание объектов этого класса. Интерфейс может унаследовать несколько интерфейсов.
Любой класс размещённый внутри интерфейса, автоматически является public static (вложенный класс)

public interface NameFile {} с public модификатором интерфейс может быть только, если имя файла совпадает с именем интерфейса
abstract interface NameInterface {} - модификатор abstract допускается, но не нужен, т.к. интерфейс автомтически абстрактый.



есть переменные - они имеют тип (могут хранить [указатель на] объекты некого типа-класса)
есть собственно объект - экземпляр класса, он же кусок выделенной памяти, который содержит поля класса и т.п. 
есть класс - он же тип. описывает поля и методы .




======================
ОБРАТНЫЙ ВЫЗОВ (Callback)
======================

При обратном вызове, программист задаёт действия, которые должны выполняться всякий раз, когда происходит некое событие.





======================
ВНУТРЕННИЙ КЛАСС 
======================

Называется класс, определённый внутри другого класса. Объект внутреннего класса имеет доступ к членам внешнего класса.
Объект внутреннего класса скрывается от классов этого же пакета. Очень удобно использовать обратный вызов. Внешний класс
может создавать в методах или в конструкторе экземпляр внутреннего класса с модификатором private. И имеет доступ к его
методам, но не к полям.





======================
ВЛОЖЕННЫЙ КЛАСС 
======================

внутренний статический класс.
Любой класс размещённый внутри интерфейса, автоматически является public static (вложенный класс) стр.260

Вложенный приватный класс (private static class):

OuterC.InnerC psc = new OuterC.InnerC(); // создание объекта возможно;




======================
ЛОКАЛЬНЫЙ ВНУТРЕННИЙ КЛАСС 
======================

Создание класса в теле метода.
Локальные классы никогда не объявляются с помощью модификаторов доступа public или protected. Их область всегда ограничивается
блоком в котором они объявлены.
Локальные классы имееют огромное приемущество - они полностью скрыты от внешнего мира и даже от остальной части класса. Ни один
мето, за исключение метода в котором объявлен локальный класс, ничего не знает об этом классе. 



======================
АНОНИМНЫЙ ВНУТРЕННИЙ КЛАСС 
======================

Создание класса у которого отсутствует имя класса и использует для создания класса имя интерфейса.

button.addActionListener(new ActionListener {
        public void actionPerformed(ActionEvent e) {
        }
};

В данном случае, создаётся анонимный класс имя которого используется от интерфейса ActionListener
При использовании имени интерфейса анонимный класс должен в себе реализовать его методы.

Если нужно использовать объекты определённые вне внутреннего класса, например аргументы в методе, 
компилятор требует, чтобы переданные на них ссылки объявлялись неизменными, с модификатором final.




======================
ВНУТРЕННИЙ КЛАСС .new и .this 
======================
Чтобы создать объект внутреннего класса, нужно создать объект внешнего класса и через ссылку на объект 
внешнего класса создать внутренний объект.  

OuterClass noc = new OuterClass();
OuterClass.InnerClass nic = oc.new InnerClass();

чтобы получить ссылку на объект внешнего класса во внутреннем классе, нужно записать имя внешнего класса 
за которым следуюет ключевое слово this.
 
NameOuterClass.this;





========================
ТИПИЗИРОВАННЫЕ И НЕ ТИПИЗИРОВАННЫЕ КОНТЕЙНЕРЫ:
========================

ArrayList может быть двух видов, 


НЕ ТИПИЗИРОВАННЫЙ ArrayList apple = new ArrayList();

В не типизированный массив, можно помещать объекты разных типов, например
apple.add(new Apple());
apple.add(new Orange());

только перед объявлением не параметризованных типов массива следуюет указать директиву


Дериктива устанваливается перед методом, который вызывается предупреждение.
@SuppressWarnings("uncheked") // подавляются только "непроверяемые" предупреждения



ТИПИЗИРОВАННЫЙ ArrayList<Apple> apple = new ArrayList<Apple>();

в типизированный массив можно помещать только объекты объявленного типа или его потомков.




ВАЖНО! Любой контейнер может быть объявлен только одного типа.

List<Shape> c1 = new ArrayList<Shape>();
List<Shape> c2 = new ArrayList<Triangle>(); - неправильно! Сужение типа контейнера невозможно. Ошибка компиляции.


Arrays.asList(); - метод получает ссылку на массив, либо список элементов раздельных запятыми,
и преобразует его в объект List. 

Важно помнить, что метод не работает с примитивными типами, т.к. является параметризованным. Только с объектами.

int[] primitivesType = new primitivesType[10];
String[] s = new String[10]

System.out.println(Arrays.asList(i).size()); // результатом будет единица!
System.out.println(Arrays.asList(s).size()); // результатом будет десять!



Можно использовать вывод Arrays.asList() на прямую, в виде List, но в этом случае, нижележащим
представлением будет массив, не допускающий изменения размеров. Вызов add(); или delete();
для такого списка приведёт к попытке изменения размера массива, а это приведёт к ошибке во 
время выполнения:

List<Integer> list = new Arrays.asList(16, 17, 18, 19, 20);
list.add(21); // ошибка времени выполнения нижележащий массив не должен изменяться в размерах.




Collections.addAll(); - получает объект Collection и, массив либо список разделённый запятыми. 
и добовляет элементы в Collection.



HashSet, HashMap - минимальное время выроботки элементов, хаотичный порядок.
Treeset, TreeMap - храняться отсортированными по возрастанию в порядке сравнения
-LinkedHashSet, LinkedHashMap - хранение элементов в порядке добавления 





========================
ОСНОВНЫЕ КОНЦЕПЦИИ ХРАНЕНИЯ ОБЪЕКТОВ В КОНТЕЙНЕРЕ
========================

В библиотеке контейнеров Java проблема хранения объектов делится на две концепции
выраженные в виде базовых интерфейсов.



***КОЛЛЕКЦИЯ - Корневой интерфейс, описывающий общую функциональность всех последовательных контейнеров.


**интерфейс List(список) хранит элементы в порядке вставки. 


Контейнеры List гарантируют определённый порядок следования элементов. Интерфейс List расширяет
базовый интерфейс Collection несколькими методами, обеспечивающими вставку и удаление элементов 
в середине списка. Существует две основные разновидности List:

*контейнер ArrayList, опимизирован для произвольного доступа к элементам, но с 
относительно медленными оперерациями вставки/удаления элементов в середине списка.

*контейнер LinkedList, оптимизирован для последовательного доступа к элементам, с быстрыми 
операциями вставки/удаления элементов в середине списка. Произвольный доступ к элементам LinkedList
выполняется относительно медленно, но по широте возможностей он превосходит ArrayList.
Класс LinkedList также содержит методы, позволяющие использовать его в качестве стека, или очереди Queue.

Методы getFirst() и element() идентичны, они возвращают начало (первый элемент) списка без его удаления
и выдают NoSuchElementException для пустого списка. 
peek() представляет собой небольшую модификацию этих двух методов. Он возращает null для пустого списка 
addFirst() вставляет элемент вначало списка.
Метод offer() делает тоже самое, что и методы add() и addLast() - добавляет элемент в конец списка.
removeLast() удаляет и возвращает последний элемент списка. 



**интерфейс Set(множество) в котором нельзя хранить повторяющиеся элементы.


В множествах Set каждое значение может храниться только в одном экземпляре. Попытки добавить 
новый экземпляр эквивалентного объекта блокируются. Множества часто используются для проверки
принадлежности, чтобы можно было легко проверить, принадлежит ли объект заданному множеству.
Важнейшей операцией Set является операция поиска, поэтому на практике обычно выбирается реализация
HashSet, оптимизированная для быстрого поиска.

*HashSet - минимальное время выборки элементов, хаотичный порядок.
*Treeset - хряняться отсортированными в порядке возрастания.
*LinkedHashSet - элементы хранятся в порядке добавления.




**интерфейс Queue(очередь) - очередь обычно представляет собой контейнер, работающий по принципу 
"первый зашёл, первый вышел" (FIFO). Элементы заносяться в очередь с одного "конца" и извлекаются с
другого в порядке их поступления. (принцип работы мясорубки)
Класс LinkedList содержит методы, поддерживающие поведение очереди, и реализует интерфейс Queue, поэтому
LinkedList может использоваться в качестве реализации Queue.

Метод offer() вставляет элемент в конец очереди, если вставка невозможна, возвращает false.
peek() и element() возвращают начальные элемент без его удаления из очереди. peek() для пустой очереди
возвращает null, а element() выдаёт исключение NoSuchElementException.
Методы poll() и remove() удаляют и возращают начальный элемент очереди, но poll() для пустой очереди
возвращает null, remove() выдаёт NoSuchElementException();


*PriorityQueue - в приоритетной очереди следующим элементом считается элемент, обладающий наивысшим
приоритетом.



***КАРТА - набор пар объектов "ключ-значение", с возможностью выборки по ключу. 


ArrayList позволяет искать объекты по порядковым номерам, поэтому в каком-то смысле он связывает 
числа с объектами. 

**интерфейс Map (карта - встречаются термины ассоциативный массив и словарь) позволяет искать объекты
по другим объектам - например, получить объект значения по объекту ключа, по аналогии с поиском
определения по слову. В контейнерах Map храняться два объекта: ключ и связанное с ним значение.




В контейнере Map, объект ключа должен быть уникальный. 

HashMap<String, String> hmap = new HashMap<String, String>(
map.put("dog","Bosco");
map.put("dog","Spot");
System.out.print(hmap.get("dog"));


Иначе, при вызове элемента по ключу, значене будет выдаваться последнего элемента в последовательности.





*HashMap - оптимизированы для быстрого доступа.
*TreeMap - хранит ключи в отсортированном порядке.
*LinkedHashMap - элементы хранятся в порядке вставки.


========================
ИТЕРАТОР, Iterator
========================

Объект обеспечивающий перемещение по последовательности объектов с выбором каждого объекта этой последовательности,
при этом программисту-клиенту не надо знать или заботиться о лежащей в ее основе структуре.(стр 288)
Iterator в Java поддерживает перемещение только в одном направлении.


* Запросить у контейнера итератор можно вызовом метода iterator(). Полученный итератор готов вернуть начальный элемент последовательности при первом вызове своего метода next();
* Получить следующий элемент последовательности вызовом метода next();
* Проверить остались ли ещё объекты в последовательности (метод hasNext())
* Удалить из последовательности последний элемент, возвращенный интератором, можно использовать метод remove();	


========================
ИТЕРАТОР, ListIterator 
========================

ListIterator - более мощная разновидность Iterator, поддерживаемая только классами List. Если Iterator 
поддерживает перемщение только вперёд ListIterator является двухсторонним.


========================
Iterable, foreach
========================

Синтаксис foreach будет работать с любым объектом Сollection. 

Collection<String> ch = new LinkedList<String>();
        Collections.addAll(ch, "Take the long way home".split(" "));
        for(String s : ch) 
            System.out.print(" '" + s + "' ");

поскольку ch является Collection пример показывает что поддержка foreach является характеристикой всех 
контейнеров Collection. Работа этой конструкции объясняется тем, что в Java SE5 появился новый интерфейс
Iterable, который содержит метод iterator() для создания Iterator, и именно интерфейс Iterable
используется в переборке последовательности в синтаксисе foreach. Следовательно, создав любой класс,
реализующий Iterable, вы сможете использовать его в синтаксисе foreach. (стр 304)




========================
СТЕК
========================

Стек называют контейнером работающим по принципу первый вошёл последним вышёл (LIFO).
Контейнер LinkedList имеет методы, напрямую связан с реализацией функциональности стека.
Метод addFirst() размещает элемент первым списке.
Метод removeFirst() удаляет и возвращает верхний элемент.
0Таким образом, два метода работают в последовательности с элементами.


public class Stack<T> {
    private LinkedList<T> storage = new LinkedList<T>();

    public void push(T incoming) { storage.addFirst(incoming); }

    public boolean empty() { return storage.isEmpty(); }

    public T peek() { return storage.getFirst(); }
    public T pop() { return storage.removeFirst(); }
}




========================
try
========================

try - перехватчик исключения
защищённая секция - область программы, в которой могут произойти исключения (блок try) за которой следует
специальный блок, отвечающий за обработку этих исключений. (секция catch)




========================
catch
========================

обработчик исключения, создаётся для каждого исключения, которое нужно перехватить. Обработчики всегда
следуют прямо за блоком try. При возникновении исключения механизм обработки исключений ищет первым из обработчиков
исключений, аргумент которого соотвествует текущему типу исключения. После этого он передаёт управление в блок catch,
и таким образом исключение считается обработанным. После предложения catch поиск обработчиков исключений прекращается.

Обрабатывать исключения следуют от более конкретного исключения к общему. Т.е. если сначала написать более общий обработчике
catch(Exception e), а за ним будет следовать более конкретный catch(FileNotFoundException e) то, второй будет игнорироваться
Такая обработка исключений считается неправильной.

========================
Модель прерывания
========================

Предполагает, что ошибка настолько серьёзна, что при возникновении исключения продолжить исполнение невозможно. Кто бы
ни возбудил исключение,  сам факт его выдачи означает, что исправить ситуацию "на месте" невозможно и возвращать управление
обратно не нужно.



========================
Альтернативная модель возобновление
========================

Подразумевает, что обработчик ошибок сделает что-то для исправления ситуации, после чего предпринимается попытка повторить
неудавшуюся операцию в надежде на успешный исход. В таком случае исключение больше напоминает вызов метода - чтобы применить
модель возобновления в Java, придётся пойти именно по этому пути (т.е. не возбуждать исключение, а вызвать метод, способный
решить проблему). Также можно создать блок try внутри цикла while, который станет снова и снова обращаться к этому блоку,
пока не будет достигнут нужный результат.



========================
throws спецификация исключений
========================

В Java дабавили в синтаксис (ОБЯЗАТЕЛЬНЫЙ для использования) при помощи которого сообщается клиенту об исключениях,
возбуждаемых методом, чтобы клиент сумел правильно обработать их. Этот синтаксис называется спецификацией исключений,
входит в объявление метода и следуюет сразу за списком агрументов.
Спецификация исключений состоит из ключевого слова throws, за которым перечисляются все возможные типы исключений. 
Обойти спецификацию исключений невозможно. Если метод возбуждает исключения и не обрабатывает их, компилятор предложит
либо обработать исключение, либо включить его в спецификацию. Жестким контролем за соблюдением правил сверху донизу
Java гарантирует правильность использования механизма исключений во время компиляции программы.


Метод подкласса не может генерировать более общие исключения, чем переопределённый им метод суперкласса. Исключения могут
конкретизироваться или не возникать вовсе. В частности, если метод в базовом классе вообще не возбуждает исключения, то и
метод подкласс не может возбуждать исключение.


========================
checked - контролируемые исключения
========================

Исключения, которые проверяются и навязываются ещё на этапе компиляции программы, называю контролируемые.
Для всех котролируемых исключений компилятор проверяет наличие соответствующих обработчиков.




========================
unchecked - неконтролируемые исключения
========================

Такие исключения означают ошибки в программе и фактически не придётся перехватывать их т.к. это происходит автоматически.
В спецификации Java любое исключение вызванно Error или RuntimeException называется неконтролируемое.
Иерархия Error описывает внутренние ошибки и ситуации, связанные с нехваткой ресурсов, в системе поддержки выполнения программ.
Ни один объект этого типа самостоятельно сгенерировать невозможно. При возникновении внутренней ошибки возможности программиста
крайне ограничены.

Исключения RuntimeException возникают в следствие ошибок программирования.

Исключения связанные с RuntimeException могут быть вызваны:

- приведение типов, 
- выход за пределы массива, 
- попытка обратиться к объекту null, 
- попытка чтения после конца файла,
- попытка получить объект Class если в строке указан несоответствующий класс, 
- попытка установить соединение, используя
- неправильный URL.



========================
Произвольные исключения
========================

Универсальный обработчик, перехватывающий любые типы исключения. Осуществляется перехватом базового класса всех исключений
Exception (существуют и другие базовые типы исключений, но класс Exception является базовым практически для всех программных
исключительных ситуаций:


catch(Exception e) {
	System.out.println("Перехвачено исключение");
}


Подобная конструкция не пропустит ни одного исключения, поэтому её следуюет размещать в самом конце списка обработчиков, во
избежание блокировки следующих за ней обработчиков исключений.
Exception не предоставит никакой полезной информации об исключительной ситуации, но можно вызвать методы из его базового типа
Throwable:

* String getMessage(), String getLocalizedMessage() возвращают подробноее сообщение об ошибке (или сообщение, локализованное
для текущего контекста).
* String toString() возвращает короткое описание объекта Throwable, включая подробное сообщение, если оно присутствует.
* void PrintStackTrace(), void PrinStackTrace(PrintStream), void PrintStackTrace(java.io.PrintWriter) выводят информацию
об объекте Throwable и трассировку стека вызовов для этого объекта. Трассировка стека вызовов показывает последовательность
вызова методов, которая привела к точке возникновения исключения. Первый вариант отправляет информацию в стандартный  поток
ошибок, второй и третий - в поток по вашему выбору. 
* Throwable fillInStackTrace() записывает в объект Throwable информацию о текущем состоянии стека. Метод используется при 
повторном возбуждении ошибок или исключений.


========================
Трассировка стека
========================

Информацию предоставляемую методом printStackTrace(), также можно получить напрямую вызовом getStackTrace(). метод возвращает
массив элементов трассировки, каждый из которых представляет один кадр стека. Нулевой элемент предоставляет вершину стека, то 
есть последний вызванный метод последовательности (точка, в которой был создан и инициализирован объект Throwable).
Соответственно, последний элемент массива представляет "низ" стека, то есть первый вызванный элемент последовательности. 




========================
Повторное возбуждение исключения
========================

В некоторых ситациях требуется заново возбудить уже перехваченное исключение; чаще всего это происходит при использовании
Exeption для перехвата всех исключений. Т.к. ссылка на текущее исключение уже имеется попросту возбуждается исключение
по этой ссылке:

catch(Exeption e) {
	System.out.println("Было возбуждено исключение");
	throw e;
}


========================
Цепочка исключений
========================

Зачастую необходимо перехватить одно исключени и возбудить следующее, не потеряв при этом информацию о первом исключении -
это называется цепочкой исключений.


========================
Стандартные исключения Java
========================

Класс Java Throwable описывает все объекты, которые могут возбуждаться как исключения. Существуют две основные разновидности
объектов Throwable (т.е. ветви наследования). 

Тип Error представляет системные ошибки и ошибки времени компиляции, которые 
обычно не перехватываются (кроме несколько случаев). 

Тип Exception может быть возбуждён из любого метода стандартной библиотеки классов Java или пользовательского метода в случае
неполадок при исполнении программы. Таким образом, для программистов интерес представляет прежде всего тип Exception. 

Тип RuntimeException только исключения RuntimeException (и производный классов) могут игнорироваться во время написания текста
программы, в то время как остальные действия компилятор осуществляет в обязательном порядке. Это объясняется тем что
RuntimeException является следствием ошибки программиста. 


========================
finally
========================

Блок finally выполняет некоторую часть программы, которая должна выполняться независимо от того, было и нет возбуждено
исключение внутри блока try.


========================
Ограничения при использовании исключений
========================

В переопределённом методе можно возбуждать только те исключения, которые были описаны в методе базового класса. Это 
полезное ограничение означает, что программа работающая с базовым классом, автоматически может работать и с объектом,
произшедшим от базового.


========================
RTTI
========================

Механизм RTTI (Runtime Type Information) предназначен для получения и использования информации о типах во время 
выполнения программы.

Существует два механизма получения информации об объектах и классах во время выполнения программы в Java. 
"Традиционный" механизм подразумеващий, что все типы доступны во время компиляции.
"Рефлексия" механизм применяемый исключительно во время выполнения программы.

Class c = Class.forName("имя класса") - объект Class загружается при непосредственной необходимости, а статическая
инициализация производится при загрузки этого объекта.

getName() - получение полного имени класса
getSimpleName() и getCanonicalName() - возвращают имя без пакета и полное имя соответственно.
isInterface() - проверяет, предоставляет ли объект Class интерфейс.
newInstance() - фактически реализует виртуальный конструктор. 



========================
Литералы class
========================

В java существует ещё один способ получения ссылки на объект Class - посредством литерала class.

NameOfObject.class

Такой способ не только проще, но и безопасней, поскольку проверка осуществляется ещё во время компиляции. К тому же
он не требует вызова Class.forName("имя класса"), а значит, является более эффективным. 
Литералы class работают со всеми обычными классами, так же как и с интерфейсами, массивами и даже с примитивами. 
Вдобавок во всех классах-обёртках для примитивных типов имеется поле с именем TYPE. Это поле содержит ссылку  на объект
Class ассоциированного с ним простейшего типа.

литерал:          ссылка на объект

boolean.class     Boolean.TYPE
char.class        Character.TYPE


newInstance() - фактически реализует виртуальный конструктор. При создании нового экземпляра методом newInstance() вы
получаете ссылку на обобщённый объект Object. Однако, полученная ссылка на самом деле указывает на фактический объект
Следовательно, перед посылкой сообщений, характерных для фактического класса, придётся провести нисходящее преобразование.
Вдобавок, объект созданный с помощью метода newInstance(), обязан определить конструктор по умолчанию.


Создание ссылки на объект Class c использованием записи .class не приводит к автоматической инициализации объекта Class.
Подготовка класса к использованию состоит из трёх этапов:

* Загрузка - выполняется загрузчиком классов. Последний находит байт-код и создаёт на его основе объект Class.
* Компоновка - в фазе компоновки проверяется байт-код класса, выделяется память для статических полей и при необходимости 
разрешаются все ссылки на классы, созданные этим классов.
* Инициализация - если у класса имеется суперкласс, происходит его инициализация, выполняются статические инициализаторы и
блоки статической инициализации.


========================
instanceof
========================

Третья форма RTTI в Java - ключевое слова instaceof, которое проверяет является ли объект экземпляром заданного типа

if(apple instanceof Fuite)
	(Apple)apple.eat(); 


========================
Динамический вызов instanceof
========================

Class.isInstance() повзоляет выполнить динамическую проверку типа объекта.



========================
КОНЦЕПЦИЯ ПАРАМЕТРИЗАЦИИ
========================

Одно из самый значительных ношвшенств Java 5 SE. Параметризованные типы позволяют создавать компоненты (преже всего,
контейнеры), которые могут легко использоваться с разными типами. 
Одна из главных причин для применения параметризованных типов заключается именно в этом: вы можете указать, какой тип 
должен храниться в контейнере и заданый тип будет поддерживаться компилятором.


class nameOfClass<T> - Суффикс <T> сообщает компилятору, что тип является параметризованным 
по типу T - при использовании класса на место T будет подставлен фактический тип.


Одно из ограничений параметризации в Java: примитивне типы не могут использоваться в качестве параметров типа.
<T> - можно использоваться только классы обёртки.


Параметризация может применяться и к отдельным методам классов. Сам класс при этом может быть параметризованным, а 
может и не быть - это не зависит от параметризованных методов. Если возможно параметризировать метод вместо целого
класса, вероятно, стоит выбрать именно этот вариант.Кроме того, статические методы не имеют доступа к параметрам
типа параметризованных классов. Если такие методы должны использовать параметризацию, это должно происходить на 
уровне метода, а не на уровне класса.
 
Также нужно учесть, что при использовании параметризованного класса параметры типов должны указываться при создании
экземпляра. Но при использовании параметризованного метода указывать параметры типа не обязательно, потому что
компилятор способен "вычислить" их за вас.


Параметрицазия может применяться к внутренним и к анонимным внутренним классам.

Иноформация о параметрах типов недоступна внутри параметризованного кода. Таким обзраом, можно узнать идентификатор
параметра типа и ограничение параметризованного типа, но фактически параметры типов, использованные для создания
конкретного экземпляра, остаются неизвестными. Параметризация в Java реализуется с приминением стирания (erasure).
Это означает, что при присваивании вся конкрентная информация о типа утрачивается. Таким образом, 
List<String> и List<Integer> действительно являются одним типом во время выполнения; обе формы стираются до своего
низкоуровневого типа List.
Главным аргументом для применения стирания является процесс перехода с непараметризованного кода на параметризованный
и интеграния параметризации в язык без нарушения работы существующих библиотек.
За стирание приходится расплачиваться. Параметризованные типы не могут использоваться в операциях в которых явно 
задействованы типы времени выполениия - пребразование типов, instanceof и выражения new. Вся информация о типах 
параметров теряется, и при написании параметризованного кода вам придётся постоянно напоминать себе об этом. 

Допустим, есть код:

class Foo<T> {
    T var;
}

может показаться, что при создании экземпляра Foo
Foo<Cat> f = new Foo<Cat>();

код class Foo должен знать, что он работает с Cat. Синаксис создаёт впечатление, что тип T подставляется повсюду внутри
класса. Но на самом деле это не так и при написании кода для класса вы должны постоянно напоминать себе: 
"Нет, это всего лишь Object".




===========================
ОГРАНИЧЕНИЯ ПАРАМЕТРИЗАЦИИ
===========================

Ограничения сужают круг параметров типов, используемых при параметризации. Хотя это позволяет предъявлять требования к типам
к которым применяется ваш параметризированный код, у ограничений имеется и другой, потанциально более важный эффект: 
возможность вызова методов, определённых в ограничивающих типах. 
Поскольку стирание уничтожает информацию о типе, при отсутствии ограничений для параметров типов могут вызываться только 
методы Object. Но, если ограничить параметр подможеством типов, вы сможете вызвать методы из этого подмножества. Для установления
ограничений в Java используется ключевое слово extends.

interface Weight { int weight(); }
interface Grade { String grade(); } 


class Fruit{ //тело }
class Apple extends Fruit{ //тело }
class Orange extends Fruit{ //тело }

class Basket<T extends Fruit> { //тело  }

Как в случае с наследованием, конкретный класс может быть один, интерфейсов может быть несколько

class Basket<T extends Fruit & Weight & Grade> { //тело  }



===========================
МЕТАСИМВОЛЫ ПАРАМЕТРИЗАЦИИ
===========================

Контейнер с элементами Apple нельзя присвоить контейнеру с элементами Fruit


class Fruit{ //тело }
class Apple extends Fruit{ //тело }

ArrayList<Fruit> basket = new ArrayList<Apple>();

Следует вспомнить, что параметризация - это не только контейнеры. В действительности утверждение следует трактовать шире:
Параметризованный тип в котором задействован тип Apple, нельзя присвоить параметризованному типу, в котором задействован
тип Fruit. Если бы как в случае с массивами, компилятор располагал достаточной инфомрацией и мог понять, что речь идёт о
контейнерах, он мог бы проявить некоторую снисходительность. Но компиялтор такой информацией не распологает, поэтому он
отказывается выполнить восходящее преобразование. Впрочем, это не является восходящим преобразованием. ArrayList с 
элементами Apple не является частным случаем ArrayList с элементами Fruit. 
Проблема в том, что речь идёт о типе контейнера, а не о типе элементов, которые в этом контейнере хранятся. В отличии от
массивов, параметризованные типы не обладают встроенной ковариантностью. Это связано с тем, что массивы полностью определяются
в языке и для них могут быть реализованы встроенные проверки как во время компиляции так и во время выполнения. Но с 
параметризованными типами компилятор и система времени выполнения не знают, что вы собираетесь делать с типами и какие правила
при этом должны действовать. 

Но иногда, между двумя разновидностями параметризованных типов всё же требуется устровить некоторую связь, аналогичному 
восходящему преобразованию. Именно это позволяют сделать метасимволы. метасимволы обеспечивают ковариантность.


class Fruit{ //тело }
class Apple extends Fruit{ //тело }
class Orange extends Fruit{ //тело }

List<? extends Fruit> basket = new ArrayList<Apple>() { 
    basket.add(new Fruit);  // ошибка компиляции добавление произвольного объекта невозможно
    basket.add(new Apple);  // ошибка компиляции добавление произвольного объекта невозможно
    basket.add(new Orange); // ошибка компиляции добавление произвольного объекта невозможно
 }

теперь basket относиться к типу List<? extends Fruit>, что можно прочитать как список с элементами любого типа, производного
от Fruit. Однако в действтиельност это не означает, что List будет содержать именно типы из семейства Fruit. Метасимвол 
означает некоторый конкретный тип, не указанный в ссылке basket. таким образом присваиваемый List должен содержать некий
конкретный тип (например Fruit, Apple) но для восходящего преобразования к basket этот тип несущественен.

Может показаться, что такое подход не совсем логичен - не удастся даже добавить Apple в List, в котором, как вы только что
указали, должны храниться Apple. Да, конечно, но компилятор то этого не знает! <? extends Fruit> вполне может указывать на
List<Orange>;


===========================
КОНТРАВАРИАНТНОСТЬ
===========================

Существуют также метасимволы супертипов. В этом случае, сообщается, что метасимвол ограничевается базовым классом некоторого
класса, при этом используется запись <? super MyClass> и даже с параметром типа <? super T>. Это позволяет безопасно  
передавать типизованный объект параметризованному типу. таким образом с использованием метасимволов супертипов становится
возможной запись в коллекцию:

class Fruit{ //тело }
class Citrus extends Fruit{ //тело }
class Orange extends Citrus{ //тело }
class Lemon extends Citrus{ //тело }

public void writeTo(List<? super Citrus> citrus) { 
    citrus.add(new Orange());  // ok
    citrus.add(new Lemon());  // ok
    citrus.add(new Fruit()); // ошибка компиляции 
 }


===========================
РЕАЛИЗАЦИЯ ПАРАМЕТРИЗОВАННЫХ ИНТЕРФЕСОВ
===========================

Класс не может реализовывать две разновидности одного параметризованного интерфейса - вследствие стирания они будут считаться
одним и тем же интерфейсом. 

iterface Payable<T>{}

class Employee implements Payable<Employee>{}




========================
КОНЦЕПЦИЯ КОРТЕЖИ
========================


При вызове метода, иногда требуется, чтобы метод возвращал несколько объектов. Команда return позволяет вернуть только
один объект, поэтому проблема решается созданием объекта, содержащего несколько возвращаемых объектов. Параметризованные
типы позволяют решить проблему один раз и избавиться от хлопот в будущем. Заодно решается проблема безопасности типов на
стадии компиляции. 
Концепция нескольких объектов, "упакованных" в один объект, называются кортежом(tuple). 

котреж на два объекта: 
public class NameClass1<A,B> { /* члены класса, тело класса */}

кортеж наследник: 
public class NameClass2<A,B,C> extends NameClass1<A,B> { super(a,b); /* члены класса, тело класса */}







========================
ARRAYS
========================

Метод для быстрого копирования из одного массива в другой.
System.arraycopy(a,0,b,0,a.length);

Метод забивает значениями 99 весь массив.
Arrays.fill(b, 99);

Пример:

int[] a = new int[5];
int[] b = new int[10];

Arrays.fill(a, 55);
Arrays.fill(b, 99);

System.arraycopy(a,0,b,0,a.length);
System.out.println(Arrays.toString(a));


Ищет элемент в отсортированном массиве. Перед вызовом
нужно отсортировать массив
Arrays.binarySearch();


Работает как с многомерными массивами примитивных типов 
так и с многомерными масивами объектов преобразует их в String();
Arrays.deepToString();


========================
INPUTSTREAM - ввод данных
========================

Назначение базового класса InputStream представлять классы, которые получают данные из различных источников:

- ByteArrayInputStream - массив байтов
- StringBufferInputStream - строка
- FileInputStream - файл
- PipedInputStream - канал (pipe) в который помещаются в один конец и извлекаются с другого.
- SequenceInputStream - последовательность различных потоков, который можно объединить в один
- другие исторчники, например, подключение к Интернету.

- FilterInputStream Абстрактный класс предоставляющий интерфейс для классов-надстроек, которые добовляют к существующим потокам
полезные свойства. 


========================
OUTPUTSTREAM - вывод данных.
========================

В данную категорию попадаются классы, определяющие, куда направляются ваши данные


- ByteArrayOutputStream - массив байтов
- FileOnputStream - файл
- PipedOutputStream - канал (pipe) в который помещаются в один конец и извлекаются с другого.

- FilterInputStream Абстрактный класс предоставляющий интерфейс для классов-надстроек, которые добовляют к существующим потокам
полезные свойства. 



========================
ДЕКОРАТОР (НАДСТРОЙКА)
========================

Наслаивание дополнительных объектов для получения новых свойств и функций у определённых объектов называется декоратором.
Интерфейс для декораторов предоставляют классы FilterInputStream FilterOutputStream. Это абстрактыне классы декораторы
производные от основных базовых классов библиотеки ввода/выовда InputStream, OutputStream. Наследование от этих классов
основное требование к классу-декоратору. 



========================
СЕРИАЛИЗАЦИЯ
========================

Сериализация объектов Java позволяет взять любой объект реализующий интерфейс Serializable, и превратить его в 
последовательность байтов, из которой потом можно полностью восстановить исходный объект. Сама по себе сериализация
интересна потому, что с её помощью можно осуществить лёгковесное долговременное хранение. Это означает, что время жизни
объекта определяется не только верменем выполнения программы - объект существует и между запусками программы. Можно взять
объект, записать его на диск, а после, при другом запуске программы, восстановить его в первоначальном виде и таким образом
получить эффект живучести.
Механизм сериализации объектов был добавлен в язык для поддержки двух расширенных возможностей. Удалённый вызов методов
Java (RMI). Позволяет работать с объектами, находящимися на других компьютерах, точно так же, как и с теми, что существуют
на текущей машине. При посылке сообщений удалённым объектам необходимо транспортировать аргументы и возвращаемые значения,
а для этого используется серилизация объектов. 
Сериализация объектов также необходима визуальным компонентам Java Bean. Информация о состоянии визуальных компонентов обычно
изменяется во время разработки. Эту информацию о состоянии необходимо сохранить, а затем при запуске программы, восстановить.
Данную задачу решает серилизация объектов.



========================
transient
========================

transient - запрещает запись некоторых полей объекта Serializable. Для примера, если взять объект Login, который содержит 
информацию о некотором сеансе входа в систему, с вводом пароля и имени пользователя. Предположим, что после проверки информации
её необходимо сохранить, выборочно, без пароля. Проще всего удовлетворить заявленным требованиям, реализуя интерфейс Serializable
и объявляя поле с паролем password как transient.

public class Logon implements Serializable {

    private String login;
    private transient String password;
}

при записи на диск будут сохранятся значения только поля login. Механизм серилизации будет игронировать значения поля password.
при восстановлении объекта поле password равно null.

Ключевое слово transient применяется только для объектов Serializable. для объектов Externalizable не применяется, т.к. эти
объекты изначально не сохраняют полей.



========================
interface Runnable 
========================

Программный поток представляет некоторую задачу или операцию, поэтому необходимы средства для описания
этой задачи. Их представляет интерфейс Runnable. Чтобы определить задачу нужно реализовать интерфейс 
Runnable и написать в нём метод run(), содержащий код выполнения нужных действий. 
Метод run() обычно содержит некоторый цикл, который продолжает выполняться до тех пор, пока не будет 
достигнуто некоторое завершающее условие выхода из цикла (например, просто вернуть управление командой 
return).
Вызов статического метода Thread.yield() в методе run() обращён к планировщику потоков (часть потогового 
механизма Java, обеспечивающая переключение процессора между потоками). Фактически он означает, что 
очередная важная часть цикла была выполенена и теперь можно на время переключиться на другую задачу.


class Robot implements Runnable {
    public void run() { //тело; Thread.yield(); }
}

public static void main(String[] args) {
    Robot robot = new Robot();
    robot.run(); // задача выполняется в пределах одного потока main();
}


Класс реализующий Runnable, должен содержать метод run(), но ничего особенного в этом методе нет - он не 
обладает никакими особыми потоковыми возможностями. Чтобы использовать многопоточное выполнение, необходимо
явно связать задачу с потоком.


public static void main(String[] args) {
    Thread robot = new Thread(new Robot());
    robot.start(); // задача выполняется паралелльно с потоком main();
}




========================
class Thread
========================

В программе, можно легко породить дополнительные потоки для выполнения дополнительных задач

class Robot implements Runnable {
    public void run() { //тело; Thread.yield(); }
}

public static void main(String[] args) {
    for(int i = 0; i < 5; i++)
        new Thread(new Robot()).start();
}

Задачи будут выполняться с друг другом, с поочерёдной активизацией и выгрузкой потоков. Переключение осуществляется автоматически
планировщиком потоков. Если на компьютере установленко несколько процессоров или процессор имеет несколько ядер то, планирощик
потоков автоматически распределяет потоки между разными процессорами.
При разных запусках программы будут распределяться потоки по разному. Поскольку работа планировщика потоков недетерминирована.

Предыдущие версии JVM не слишком часто выполняли квантование времени. От этого может тоже менятся распреденеие
потоков. Более поздние версии JDK обеспечивают более качественное квантование, и каждый поток регулярно получает
свою долю внимания. 

Когда метод main() создаёт объекты-потоки Thread, он не сохраняет на них ссылки. Обычный объект "забытый" таким образом, стал бы 
лёгкой добычей сборщиа мусора, но только не поток-объект Thread. Каждый поток Thread самостоятельно регистрирует себя, т.е. на самом
деле ссылка на него где-то существует, и сборщик мусора не вправе удалить его объект.

В очень простых случаях можно использовать решение с прямым наследованием Thread
class Robot extends Thread {}





========================
Executors исполнители
========================

Исполнители которые появились в java.util.concurrent в Java5SE упрощают многозадачное программирование за счёт автоматизации управления
объектами Thread. Они создают дополнителнкую логическую прослойку между клиентом и выполнением задачи; Задача выполняется не напрямую
клиентом, а промежуточным объектом. Исполнители позволяют управлять выполнением асинхронных задач без явного управления жизненным
циклом потоков. Именно такой способ запуска задач рекомендуется использовать в Java6SE. Вместо явного создания объектов Thread можно
воспользоваться исполнителем. 
Объект ExecutorService умеет создават необходимый контекст для выполнения объектов Runnable. 

Пример:

class Robot implements Runnable {
    public void run() { //тело; Thread.yield(); }
}

public static void main(String[] args) {
    ExecutorService exe = Executors.newCachedThreadPool();
    for(int i = 0; i < 5; i++)
        exe.execute(new Robot());
    exe.shutdown();
}


Очень часто для создания и управляения всеми задачами в ситстеме достаточно одного исполнителя.
В потоковом пуле фиксированного размера используется ограниченный набор потоков для выполнения переданных задач.
    
    ExecutorService exe = Executors.newFixedThreadPool(2);
    
    for(int i = 0; i < 5; i++)
        exe.execute(new Robot());
    exe.shutdown();

С FixedThreadPool дорогостоящая операция создания потоков выполняется только один раз, в самом начале, поэтому количество потоков
остаётся фиксированным.


Исполнитель SingleThreadExecutor представляет собой аналог FixedThreadPool с одним потоком. Он может быть полезен для долгосрочных
операций, например, прослушивание входящих подключений по сокету. Если SingleThreadExecutor передаётся более одной задачи, эти задачи
ставятся в очередь и каждая из них отрабатывает до завершения перед началом следующей задачи. При чём все они используют один и тотже
поток.




========================
Callable возврат значений из задач
========================

Интерфейс Runnable представляет отедльную задачу, которая выполняет некоторую работу, но не возвращает значения. Если необходимо, чтобы
задача возвращала значение то, нужно реализовать интерфейс Callable. Для его вызова используется метод submit() вместо start()
Параметризированный интерфейс Callable имеет параметр типа представляющий возвращаемое значение метода call() (вместо run())
Метод submit() возвращает объект Future, параметризованный по типу результата, возвращаемому Callable. Можно обратиться к Future с
запросом isDone(), чтобы узнать заверешна ли операция.
После завершения задачи и появления результата проводится его выборка методом get();

public class Robot implements Callable<String> {
    private int i;
    Robot(int i) { this.i = i; }
    public String call() { return "Robot" + i; }



    public static void main(String[] args) {
        ExecutorService exe = Executors.newCachedThreadPool();
        ArrayList<Future<String>> result = new ArrayList<Future<String>>();
        for(int i = 0; i < 5; i++)
            result.add(exe.submit(new Robot(i)));

        for(Future<String> s : result)
            try {
                    System.out.println(s.get());

            } catch(InterruptedException e) {
                    System.out.println(e);
                    return;
            } catch(ExecutionException e) {
                    System.out.println(e);
            } finally {
                    exe.shutdown();
            }
    }
}



========================
TimeUnit == Thread.sleep()
========================

В Java5SE появлиась новая вресия sleep(), оформленная ввиде класса TimeUnit. Она делает программу более наглядной поскольку
можно указать единицы измерения продолжительности задержки. На некоторых платформах задачи выполняются в порядке идеального
распределения - от 0 до 4, затем снова от 4 до 0. Вполне логично, потому что после каждой команды вывода задача переходит в
состояние ожидания, что позволяет планирощику потоков переключиться на другой поток.
Если потребуется выполнять порядком выполнения задач, нужно использовать средства синхронизации или же вообще отказаться от
использования потоков и написать собственные функции синхронизации которые передают управление друг другу в нужном порядке.

public void run() {

    Thread.sleep(100) // старый стиль
    TimeUnit MILLISECONDS.sleep(100);
}


========================
Priority Приоритет
========================

Приоритет потока сообщает планировщику инфомацию об относительной важности потока. Хотя порядок обращения процессора к 
существующему набору потоков и не детерминирова, если существует несколько приостановленных потоков одновременно ожидающих
запуска, планирощик сначала запустит поток с большим приоритетом.
Приоритет должен задаваться вначале метода run()


public void run() {
    Thread.currentThread().setPriority(Thread.MIN_PRIORITY)
    //тело
}


Thread.MIN_PRIORITY
Treahd.NORM_PRIORITY
Treahd.MAX_PRIORITY


В пакете JDK предусмотрено десять уровней приоритетов, однако это не слишком согласуется с большенством операционных систем.



volatile - без оптимизации


========================
yield предача управления
========================

Если вы знаете, что в текущей итерации run() сделано всё необходимое, вы можете подсказать механизму планирования потоков, что
что процессором теперь может восползоваться другой поток. Эта подсказка не более чем рекомендация. Нет никакой гарантии, что
планировщик потоков прислушается к ней. Вызывая yield() вы сообщаете системе, что в ней могут выполняться другие потоки того же
приоритета.



========================
Потоки демоны
========================


Демоном назывется поток предоставляющий некоторый сервис, работая в фоновом режиме, 
при этом не является её неотъемлемой частью.

Thread daemon = new Thread(задание);
daemon.setDaemon(true); // необходимо вызвать перед start()
daemon.start();

чтобы назначит поток демоном, следует перед его запуском вызвать setDaemon();
чтобы узнать, является ли поток демоном, нужно вызвать метод isDeamon();

Если поток является демоном, то все потоки, которые он производит, также будут демонами. 

class Robot implements Runnabel {
    private Thread[] t = new Thread[10];

    public void run() 
        for(int i = 0; i < t.length; i++)
            t[i].start();
    }
}

class CreateRobot {
    public static void main(String[] args) {
        Thread create = new Thread(new Robot);
        create.setDeamon(true);
        create.start();
    }
}
 

Поток create переводится в режим демона, а затем порождает группу новых потоков, которые явно
не назначаются демонами, но при этом всё равно оказываются ими.

Демоны завершают свою работу внезапно, при завершении работы последнего потока НЕ демона. Таким
образом, сразу же при выходи из main() JVM немедленно прерывает работу всех демонов, не соблюдая
никакие формальности. Невозможность корректоного завершения демонов ограничивает возможности их
применения. Объекты Executor оказываются более удачным решением потому что все задачи находятся
под управлением Executor, могут быть завершены одновременно.



=========================================================
synchronized
=========================================================

В Java есть встроенная поддержка для предотвращения конфликтов. Когда поток желает выполнить фрагмент
кода, охраняемый словом synchronized, он проверяет, доступен ли семафор, получает доступ к семафору,
выполяет код и освобождает семафор.

для управления доступом к разделяемому ресурсу вы сначала помещаете его внутрь объекта. После этого
любой метод, получивший доступ к ресурсу, может быть объявлен как synchronized. Это означает, что
если задача выполняется внутри одного из объявленных как synchronized методов, все остальные потоки
не сумеют зайти ни в какой synchronized метод до тех пор, пока первый поток не вернётся из своего 
вызова.

По аналогии (ванной комнаты), пока один человек находится в ванной комнате под закрытой дверью все 
остальные желающие принять душ ожидают с другой стороны.


=========================================================
volatile
=========================================================

Ключевое слово volatile обеспечивает видимость в рамках приложения. Если поле объявлено как volatile
это означает, что сразу же после записи в поле изменеия будет отражено во всех последующих операциях
чтения. Утверждение истенное даже при участии локальных кэшей - поля volatile немедленно записываются
в основную память, и дальнейшее чтение происходит из основной памяти.











=========================================================
КОВАРИАНТНОСТЬ ВОЗВРАЩАЕМЫХ ТИПОВ -
=========================================================

Переопределенный метод подкласса может вернуть тип, производный от типа, возвращаемого методом базового класса.

Главное отличие Java SE 5 от предыдущих версий Java заключается в том, что старые версии Java заставляли 
переопределённый метод process() возвращать Grain тип вместо Wheat, хотя тип Wheat, производный от Grain, является
допустимым возращаемым типом. Ковариантность, возвращаемых типов позволяет вернуть более специализированный тип Wheat.



class Grain {
    public String toString() { return "Grain"; }
}
class Wheat extends Grain {
    public String toString() { return "Wheat"; }
}
class Mill {
    Grain process() { return new Grain(); }
}
class WheatMill extends Mill {
    Wheat process() { return new Wheat();}
}

public class CovariantReturn {
    public static void main(String[] main) {
        Mill m = new Mill();
        Grain g = m.process();
        System.out.println(g);
        m = new WheatMill();
        g = m.process();
        System.out.println(g);
    }
}
	